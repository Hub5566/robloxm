local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local library = loadstring(game:HttpGet("https://pastefy.app/ud7GghOq/raw", true))()
local devv = require(game:GetService("ReplicatedStorage").devv)
local Signal = devv.load("Signal")
game.TextChatService.ChatWindowConfiguration.Enabled = true
game:GetService("RunService").Heartbeat:Connect(function()
    workspace.CurrentCamera.FieldOfView = 120
end)

-- 全局变量定义（修复未定义报错）
local killoppEnabled = false
local ignoreFriendsEnabled = false
local autohlod = false
local lock = false
local selectedItem = nil
local processedATM = {} -- ATM已处理标记表

-- 好友检测与传送逻辑
local function isFriend(targetPlayer)
    return LocalPlayer:IsFriendsWith(targetPlayer.UserId)
end 
local function teleportBehindTarget(targetPlayer)
    local targetCharacter = targetPlayer.Character 
    if not targetCharacter then return end 
    if targetCharacter:FindFirstChild('ForceField') or isFriend(targetPlayer) then return end 
    local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
    local localCharacter = LocalPlayer.Character 
    local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if targetRoot and localRoot then 
        local behindCFrame = targetRoot.CFrame * CFrame.new(0,0,3)
        localRoot.CFrame = behindCFrame 
    end 
end 
local teleportLoop = nil 
local function startTeleportLoop()
    if teleportLoop then teleportLoop:Disconnect() end 
    teleportLoop = RunService.Heartbeat:Connect(function()
        for _,player in ipairs(Players:GetPlayers()) do 
            if player ~= LocalPlayer then 
                teleportBehindTarget(player)
                task.wait(1)
            end 
        end
    end)
end 
local function stopTeleportLoop()
    if teleportLoop then 
        teleportLoop:Disconnect()
        teleportLoop = nil 
    end 
end

-- 加速行走逻辑
local speed = 1 
local tpEnabled = true 
local heartbeatConnection = nil 
local character, humanoid 
local function setupCharacter()
    character = LocalPlayer.Character 
    if character then 
        humanoid = character:WaitForChild("Humanoid")
        humanoid.Died:Connect(function()
            repeat task.wait() until LocalPlayer.Character ~= nil 
            setupCharacter()
            if tpEnabled then startTPWalk() end 
        end)
    end 
end 
local function startTPWalk()
    if heartbeatConnection then heartbeatConnection:Disconnect() end 
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        if not tpEnabled or not character or not humanoid or humanoid.Health <= 0 then return end 
        if humanoid.MoveDirection.Magnitude > 0 then 
            local currentCFrame = character.PrimaryPart.CFrame 
            local newPosition = currentCFrame.Position + (humanoid.MoveDirection * speed)
            character:SetPrimaryPartCFrame(CFrame.new(newPosition) * currentCFrame.Rotation)
        end 
    end)
end 
local function stopTPWalk()
    if heartbeatConnection then 
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil 
    end 
end 
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter 
    setupCharacter()
end)
setupCharacter()

-- 自动收集基础逻辑（保留原生拾取逻辑）
local autoCollectConnections = {}
local humanoidRootPart = nil 
LocalPlayer.CharacterAdded:Connect(function(char)
    humanoidRootPart = char:WaitForChild("HumanoidRootPart")
end)
if LocalPlayer.Character then 
    humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end 
-- 核心：提取原生拾取逻辑为独立函数
local function triggerCollectCustom(prompt)
    if not prompt then return end
    prompt.HoldDuration = 0
    prompt.RequiresLineOfSight = false
    for i=1,10 do
        fireproximityprompt(prompt)
        task.wait(0.1)
    end
end

-- ====================== 储物柜解锁核心函数（新增） ======================
local LOOP_INTERVAL = 0.5
local FORCE_UNLOCK_LOCKER = false
local lockerUnlockLoop = nil
local isBackpackOpen = false -- 新增：背包状态标记

local function forceUnlockLockerSlots()
    if LocalPlayer:GetAttribute("lockerSlots") ~= 999 then
        LocalPlayer:SetAttribute("lockerSlots", 999)
        print("[储物柜解锁] 已强制设置槽位为 999")
    end
end

local function showAllLockerPages()
    local load = nil
    pcall(function()
        load = require(ReplicatedStorage.devv).load
    end)

    -- 非框架环境
    if not load then
        local PlayerGui = LocalPlayer:FindFirstChild("PlayerGui")
        local BackpackUI = PlayerGui:FindFirstChild("Backpack") or PlayerGui:FindFirstChild("Inventory")
        if not BackpackUI then return end
        local LockerPanel = BackpackUI:FindFirstChild("Holder") and BackpackUI.Holder:FindFirstChild("Locker")
        if not LockerPanel then return end

        -- 修复：ScreenGui 用 Enabled 而不是 Visible
        if LockerPanel:IsA("GuiObject") then
            LockerPanel.Visible = true
        end
        
        -- 显示所有槽位
        local slotFrame = LockerPanel:FindFirstChild("Frame")
        if slotFrame then
            for _, slot in ipairs(slotFrame:GetChildren()) do
                if slot:IsA("GuiObject") then slot.Visible = true end
            end
        end

        local UnlockAllBtn = LockerPanel:FindFirstChild("Buttons") and LockerPanel.Buttons:FindFirstChild("UnlockAll")
        if UnlockAllBtn then
            UnlockAllBtn.Visible = true
            local PriceLabel = UnlockAllBtn:FindFirstChild("Label")
            if PriceLabel then PriceLabel.Text = "已解锁全部" end
            local DiscountLabel = UnlockAllBtn:FindFirstChild("Discount")
            if DiscountLabel then DiscountLabel.Visible = false end
        end
        return
    end

    -- devv 框架环境
    local GUILoader = load("GUILoader")
    local BackpackUI = GUILoader.Get("Backpack")
    local LockerPanel = BackpackUI.Holder.Locker

    -- 修复：ScreenGui 用 Enabled 而不是 Visible
    if LockerPanel:IsA("GuiObject") then
        LockerPanel.Visible = true
    end
    if BackpackUI.Holder.Backpack.LockerText:IsA("GuiObject") then
        BackpackUI.Holder.Backpack.LockerText.Visible = true
    end

    local slotFrame = LockerPanel.Frame
    for _, slot in ipairs(slotFrame:GetChildren()) do
        if slot:IsA("GuiObject") then slot.Visible = true end
    end

    local oldUpdatePage = nil
    pcall(function()
        oldUpdatePage = getfenv(2).updatePage_upvr
    end)
    if oldUpdatePage then
        getfenv(2).updatePage_upvr = function() end
    end

    local UnlockAllBtn = LockerPanel.Buttons.UnlockAll
    if UnlockAllBtn then
        UnlockAllBtn.Visible = true
        UnlockAllBtn.Label.Text = "已解锁全部页面"
        UnlockAllBtn.Discount.Visible = false
    end

    local PageSelector = LockerPanel.Buttons.PageSelector
    if PageSelector then
        PageSelector.Left.Visible = false
        PageSelector.Right.Visible = false
        PageSelector.PageNum.Text = "全部已解锁"
    end
end

-- 背包状态监听（修复：用 Enabled 代替 Visible）
local function setupBackpackListener()
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    local BackpackUI = PlayerGui:FindFirstChild("Backpack") or PlayerGui:FindFirstChild("Inventory")
    if not BackpackUI then return end

    -- 监听背包显隐：ScreenGui 用 Enabled 属性
    local function onBackpackVisibilityChanged()
        -- 修复：判断 ScreenGui 的 Enabled（而不是 Visible）
        isBackpackOpen = BackpackUI.Enabled
        if FORCE_UNLOCK_LOCKER then
            if isBackpackOpen and not lockerUnlockLoop then
                lockerUnlockLoop = task.spawn(function()
                    while FORCE_UNLOCK_LOCKER and isBackpackOpen do
                        task.wait(LOOP_INTERVAL)
                        forceUnlockLockerSlots()
                        showAllLockerPages()
                    end
                    lockerUnlockLoop = nil
                end)
            elseif not isBackpackOpen and lockerUnlockLoop then
                task.cancel(lockerUnlockLoop)
                lockerUnlockLoop = nil
            end
        end
    end

    -- 初始检测
    onBackpackVisibilityChanged()
    -- 修复：监听 Enabled 变化（而不是 Visible）
    BackpackUI:GetPropertyChangedSignal("Enabled"):Connect(onBackpackVisibilityChanged)
end
setupBackpackListener()

-- 冷却配置
local TP_COOLDOWN = 0.5 
local lastTpTime = 0 

-- 封禁信息标签页
local SnowRUN = game:GetService("RunService")
local b1 = require(game:GetService('ReplicatedStorage').devv).load('v3item').inventory.items
local window = library:new("新年快乐！")
local tab = window:Tab("封禁信息")
local section = tab:section("封禁信息", true)
local banReasonLabel = section:Label("封禁原因：无")
local banCountLabel = section:Label("封禁次数：无")
local isBannedLabel = section:Label("是否封禁：否")
local banTimeLabel = section:Label("封禁时间：无")
local unbanTimeLabel = section:Label("解封时间：无")
local function fmt(ts)
    return os.date("%Y-%m-%d %H:%M:%S",ts)
end 
local function a123()
    local banReason = nil 
    local banCount = nil 
    local isBanned = false 
    local banAt = nil 
    local unbanAt = nil 
    local remainingTime = nil 
    for _,entry in ipairs(getgc(true)) do 
        if type(entry) == "table" then 
            local reason = rawget(entry,"shadowbanned")
            if reason then 
                banReason = reason 
                isBanned = true 
            end 
            local count = rawget(entry,"shadowbans")
            if count then 
                banCount = tostring(count)
                isBanned = true 
            end 
            local at = rawget(entry,"shadowbannedAt")
            if at then banAt = fmt(at) end 
            local exes = rawget(entry,"shadowbannedExpires")
            if exes then 
                unbanAt = fmt(exes)
                local now = os.time()
                local rem = exes - now 
                if rem > 0 then 
                    local d = math.floor(rem/86400); rem = rem%86400 
                    local h = math.floor(rem/3600); rem = rem%3600 
                    local m = math.floor(rem/60); rem = rem%60 
                    local s = rem 
                    remainingTime = string.format("%d天 %d小时 %d分 %d秒",d,h,m,s)
                else 
                    remainingTime = "已过期" 
                end 
            end 
        end 
    end 
    banReasonLabel.Text = "封禁原因："..(banReason or "无")
    banCountLabel.Text = "封禁次数："..(banCount or "无")
    isBannedLabel.Text = "是否封禁："..(isBanned and "是" or "否")
    banTimeLabel.Text = "封禁时间："..(banAt or "无")
    unbanTimeLabel.Text = "解封时间："..(unbanAt or "无")
    return isBanned,banReason,banCount,banAt,unbanAt,remainingTime 
end 
task.spawn(function()
    a123()
end)

-- 玩家标签页
local main = window:Tab("玩家")
local player = main:section("玩家", true)
player:Button("透视ESP",function()  
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer 
    local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local LocalHead = LocalCharacter:WaitForChild("Head")
    local playerConnections = {}
    local function updateNametag(player,textLabel,head)
        local character = player.Character 
        if not character then return end 
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local targetHead = character:FindFirstChild("Head")
        if humanoid and targetHead and humanoid.Health > 0 then 
            local distance = (LocalHead.Position - targetHead.Position).Magnitude 
            textLabel.Text = string.format("%s\n血量: %d/%d\n距离: %.1fm",player.Name,math.floor(humanoid.Health),math.floor(humanoid.MaxHealth),distance)
            textLabel.Visible = true 
        else 
            textLabel.Visible = false 
        end 
    end 
    local function createNametag(player)
        if player == LocalPlayer then return end 
        playerConnections[player] = {}
        local function setupCharacter(character)
            local head = character:WaitForChild("Head")
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "PlayerNametag" 
            billboard.Adornee = head 
            billboard.Size = UDim2.new(0,200,0,80)
            billboard.StudsOffset = Vector3.new(0,3,0)
            billboard.AlwaysOnTop = true 
            billboard.Parent = head 
            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1,0,1,0)
            textLabel.Font = Enum.Font.GothamBold 
            textLabel.TextSize = 8 
            textLabel.TextColor3 = Color3.new(1,0,0)
            textLabel.TextStrokeColor3 = Color3.new(0,0,0)
            textLabel.TextStrokeTransparency = 0.3 
            textLabel.BackgroundTransparency = 1 
            textLabel.TextYAlignment = Enum.TextYAlignment.Top 
            textLabel.Parent = billboard 
            local heartbeatConn = RunService.Heartbeat:Connect(function()
                if not character or not character.Parent then 
                    heartbeatConn:Disconnect()
                    return 
                end 
                updateNametag(player,textLabel,head)
            end)
            table.insert(playerConnections[player],heartbeatConn)
            local characterRemovedConn 
            characterRemovedConn = character.AncestryChanged:Connect(function(_,parent)
                if parent == nil then 
                    billboard:Destroy()
                    heartbeatConn:Disconnect()
                    characterRemovedConn:Disconnect()
                end 
            end)
            table.insert(playerConnections[player],characterRemovedConn)
        end 
        if player.Character then setupCharacter(player.Character) end 
        local charAddedConn = player.CharacterAdded:Connect(setupCharacter)
        table.insert(playerConnections[player],charAddedConn)
    end 
    local function removeNametag(player)
        if playerConnections[player] then 
            for _,conn in ipairs(playerConnections[player]) do 
                conn:Disconnect()
            end 
            playerConnections[player] = nil 
        end 
        if player.Character then 
            local head = player.Character:FindFirstChild("Head")
            if head then 
                local nametag = head:FindFirstChild("PlayerNametag")
                if nametag then nametag:Destroy() end 
            end 
        end 
    end 
    Players.PlayerAdded:Connect(function(player)
        createNametag(player)
        local leavingConn 
        leavingConn = player.AncestryChanged:Connect(function(_,parent)
            if parent == nil then 
                removeNametag(player)
                leavingConn:Disconnect()
            end 
        end)
    end)
    for _,player in ipairs(Players:GetPlayers()) do 
        if player ~= LocalPlayer then 
            createNametag(player)
            local leavingConn 
            leavingConn = player.AncestryChanged:Connect(function(_,parent)
                if parent == nil then 
                    removeNametag(player)
                    leavingConn:Disconnect()
                end 
            end)
        end 
    end 
    LocalPlayer.CharacterAdded:Connect(function(character)
        LocalCharacter = character 
        LocalHead = character:WaitForChild("Head")
    end)
end)
player:Slider('加速设置', 'SpeedSlider', 1, 1, 15, false, function(value)
    speed = value
end)
player:Toggle("速度开关", "speed", false, function(value)
    tpEnabled = value
    if value then
        startTPWalk()
    else
        stopTPWalk()
    end
end)
local jumpConnection
player:Toggle("连跳", "jump", false, function(value)
    if value then 
        jumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
            if humanoid and humanoid.Health > 0 then 
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end 
        end)
    else 
        if jumpConnection then
            jumpConnection:Disconnect()
            jumpConnection = nil 
        end 
    end
end)

-- 物品标签页
local main = window:Tab("物品")
local kill = main:section("战斗", true)
kill:Slider("物品栏数量", "taunt_interval", 6, 1, 9, false, function(value)
    local sum = require(game.ReplicatedStorage.devv.client.Objects.v3item.modules.inventory)
    sum.numSlots = value
end)

-- 魔法标签页（新增储物柜功能）
local main = window:Tab("魔法")
local zzzz = main:section("魔法", true)
zzzz:Label("RPG功能已移除 其他功能正常运行")

-- ====================== 魔法标签页添加储物柜解锁功能 ======================
local lockerSection = main:section("储物柜解锁", true)
lockerSection:Toggle("循环解锁储物柜（仅背包打开时生效）", "", false, function(v)
    FORCE_UNLOCK_LOCKER = v
    if lockerUnlockLoop then 
        task.cancel(lockerUnlockLoop)
        lockerUnlockLoop = nil 
    end
    if FORCE_UNLOCK_LOCKER and isBackpackOpen then
        lockerUnlockLoop = task.spawn(function()
            while FORCE_UNLOCK_LOCKER and isBackpackOpen do
                task.wait(LOOP_INTERVAL)
                forceUnlockLockerSlots()
                showAllLockerPages()
            end
            lockerUnlockLoop = nil
        end)
        print("储物柜循环解锁已开启")
    else
        print("储物柜循环解锁已关闭")
    end
end)
lockerSection:Button("立即解锁储物柜（单次）", function()
    if isBackpackOpen then
        forceUnlockLockerSlots()
        showAllLockerPages()
        print("储物柜已单次解锁")
    else
        print("请先打开背包再执行单次解锁")
    end
end)
-- ==========================================================================

-- 购买标签页
local main = window:Tab("购买")
local qtl = main:section("购买", true)
local dropdown = qtl:Dropdown("选择物品", "Items", {}, function(value)
    selectedItem = value 
end)
local itemsOnSale = workspace:FindFirstChild("ItemsOnSale")
if itemsOnSale then 
    local itemNames = {}
    local seenNames = {}
    for _,item in ipairs(itemsOnSale:GetChildren()) do 
        if not seenNames[item.Name] then 
            table.insert(itemNames,item.Name)
            seenNames[item.Name] = true 
        end 
    end 
    dropdown:SetOptions(itemNames)
end
qtl:Button("购买物品", function()
    if selectedItem then
        Signal.InvokeServer("attemptPurchase", selectedItem)
    end
end)
qtl:Button("购买子弹", function()
    if selectedItem then
        Signal.InvokeServer("attemptPurchaseAmmo", selectedItem)
    end
end)

-- 附属标签页
local main = window:Tab("附属")
local qtl1 = main:section("附属", true)
qtl1:Toggle("即时互动","", false, function(v)
    autohlod = v
    if autohlod then
        local function modifyPrompt(prompt)
            prompt.HoldDuration = 0 
        end 
        local function isTargetPrompt(prompt)
            local parent = prompt.Parent 
            while parent do 
                if parent == workspace then return true end 
                local bankRobbery = workspace:FindFirstChild("BankRobbery")
                if bankRobbery and parent == bankRobbery:FindFirstChild("VaultDoor") then 
                    return true 
                end 
                parent = parent.Parent 
            end 
            return false 
        end 
        for _,prompt in ipairs(workspace:GetDescendants()) do 
            if prompt:IsA("ProximityPrompt") and isTargetPrompt(prompt) then 
                modifyPrompt(prompt)
            end 
        end 
        workspace.DescendantAdded:Connect(function(instance)
            if instance:IsA("ProximityPrompt") and isTargetPrompt(instance) then 
                modifyPrompt(instance)
            end 
        end)
    end
end)
qtl1:Button("停止角色动画", function()
    local plr = Players.LocalPlayer
    if not plr.Character then return end
    plr.Character.Animate.Disabled = false
    local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
    for i, track in pairs (animtrack) do
        track:Stop()
    end
end)

-- 自动标签页
local main = window:Tab("自动")
local auto = main:section("自动", true)

-- 自动购买撬锁
auto:Toggle("自动购买撬锁","", false, function(v)
    lock = v
    if lock then
        task.spawn(function()
            while lock and task.wait() do  
                local localPlayer = Players.LocalPlayer
                if localPlayer.Character then
                    local rootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        Signal.InvokeServer("attemptPurchase", "Lockpick")
                    end
                end
            end
        end)
    end
end)

-- 自动消耗大型/中型礼物
local autouseGift = false
local giftUseLoop = nil
local function useGiftItems()
    local devv = require(game:GetService('ReplicatedStorage').devv)
    local item = devv.load('v3item')
    local Signal = devv.load("Signal")
    for i, v in next, item.inventory.items do
        if v.name == 'Large Present' or v.name == 'Medium Present' then
            local useid = v.guid
            Signal.FireServer("equip", useid)
            Signal.FireServer("useConsumable", useid)
            Signal.FireServer("removeItem", useid)
            break
        end
    end
end
auto:Toggle("自动消耗大型/中型礼物", "", false, function(v)
    autouseGift = v
    if giftUseLoop then 
        task.cancel(giftUseLoop)
        giftUseLoop = nil 
    end
    if autouseGift then
        giftUseLoop = task.spawn(function()
            while autouseGift do 
                useGiftItems()
                task.wait(1)
            end 
        end)
    end
end)

-- 自动消耗所有可消耗品
local autouseAll = false
local useAllLoop = nil
local function useAllConsumables()
    local devv = require(game:GetService('ReplicatedStorage').devv)
    local item = devv.load('v3item')
    local Signal = devv.load("Signal")
    for i, v in next, item.inventory.items do
        if v.name == 'Large Present' or v.name == 'Medium Present' or v.name == 'Green Lucky Block' or v.name == 'Orange Lucky Block' or v.name == 'Purple Lucky Block' or v.name == 'Electronics' or v.name == 'Weapon Parts' then
            local useid = v.guid
            Signal.FireServer("equip", useid)
            Signal.FireServer("useConsumable", useid)
            Signal.FireServer("removeItem", useid)
            break
        end
    end
end
auto:Toggle("自动消耗所有可消耗品","", false, function(v)
    autouseAll = v
    if useAllLoop then 
        task.cancel(useAllLoop)
        useAllLoop = nil 
    end
    if autouseAll then
        useAllLoop = task.spawn(function()
            while autouseAll do 
                useAllConsumables()
                task.wait(0.5)
            end 
        end)
    end
end)

-- 抢劫银行
local BankFuncEnabled = false
local UIEnabled = true
local hrp = nil
local bankLoopInterval = 0.01
local concurrentThreads = 3
local TargetConfigs = {[4] = {
    Name = "BankCash极速偷盗",
    Type = "BankLoop",
    TargetPath = {"BankRobbery", "BankCash", "Main"},
    PromptPath = {"Attachment", "ProximityPrompt"},
    Offset = Vector3.new(0, 0.5, 0)
}}
local function getBankPrompt(config)
    local target = workspace
    for _, name in ipairs(config.TargetPath) do 
        target = target:FindFirstChild(name)
        if not target then return end 
    end
    local prompt = target
    for _, name in ipairs(config.PromptPath) do 
        prompt = prompt:FindFirstChild(name)
        if not prompt then return end 
    end
    return prompt:IsA("ProximityPrompt") and prompt or nil
end
local function triggerBankSteal(config)
    local prompt = getBankPrompt(config)
    if prompt then 
        prompt.HoldDuration = 0 
        fireproximityprompt(prompt)
        return 
    end
    for _, remote in ipairs(game.ReplicatedStorage:GetDescendants()) do
        if remote:IsA("RemoteEvent") and (remote.Name:find("Steal") or remote.Name:find("Bank")) then 
            pcall(function()
                remote:FireServer()
            end)
            return 
        end
    end
end
local function getCurrentTarget()
    local config = TargetConfigs[4]
    local target = workspace
    for _, name in ipairs(config.TargetPath) do 
        target = target:FindFirstChild(name)
        if not target then return end 
    end
    return target:IsA("BasePart") and target or nil
end
local function getCharacter()
    local LocalPlayer = game:GetService("Players").LocalPlayer
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    hrp = character:FindFirstChild("HumanoidRootPart")
    return character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
end
for i = 1, concurrentThreads do
    task.spawn(function()
        while true do 
            task.wait(bankLoopInterval / concurrentThreads)
            getCharacter()
            if not BankFuncEnabled or not hrp then continue end 
            local config = TargetConfigs[4]
            local target = getCurrentTarget()
            if target then
                hrp.CFrame = CFrame.new(target.Position + config.Offset)
            end 
            triggerBankSteal(config)
        end 
    end)
end
auto:Toggle("m抢劫银行", "16384", false, function(value)
    if not UIEnabled then return end 
    BankFuncEnabled = value 
end)

-- 自动拾取-礼物&空标（保留原生逻辑）
local AutoCollectXl = false
local collectXlLoop = nil
local function collectGiftAirdrop()
    while AutoCollectXl do
        task.wait(0.05)
        local plr = game:GetService("Players").LocalPlayer
        local char = plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end
        local root = workspace.Game and workspace.Game.Entities.ItemPickup
        if not root then continue end
        for _, l in ipairs(root:GetChildren()) do
            for _, v in ipairs(l:GetChildren()) do
                local prompt = v:FindFirstChildOfClass("ProximityPrompt")
                if prompt and (prompt.ObjectText == "Medium Present" or prompt.ObjectText == "Large Present" or prompt.ObjectText == "Airdrop Marker" or prompt.ObjectText == "Money Printer" or prompt.ObjectText == "Void Gem" or prompt.ObjectText == "Military Armory Keycard" or prompt.ObjectText == "Blue Candy Cane")  then
                    hrp.CFrame = v.CFrame + Vector3.new(0, 2, 0)
                    triggerCollectCustom(prompt)
                    break
                end
            end
        end
    end
end
auto:Toggle("自动拾取珍贵物品", "", false, function(v)
    AutoCollectXl = v
    if collectXlLoop then 
        task.cancel(collectXlLoop)
        collectXlLoop = nil 
    end
    if AutoCollectXl then
        collectXlLoop = task.spawn(collectGiftAirdrop)
    end
end)

-- 自动拾取-材料（保留原生逻辑）
local autocl = false
local collectClLoop = nil
local function collectMaterial()
    while autocl do
        task.wait(0.05)
        local localPlayer = Players.LocalPlayer
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            local rootPart = localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                for _, l in pairs(game:GetService("Workspace").Game.Entities.ItemPickup:GetChildren()) do
                    for _, v in pairs(l:GetChildren()) do
                        if v.ClassName == "MeshPart" or v.ClassName == "Part" then
                            for _, e in pairs(v:GetChildren()) do
                                if e.ClassName == "ProximityPrompt" and (e.ObjectText == "Electronics" or e.ObjectText == "Weapon Parts") then
                                    local itemCFrame = v.CFrame
                                    rootPart.CFrame = itemCFrame * CFrame.new(0, 2, 0)
                                    e.RequiresLineOfSight = false
                                    e.HoldDuration = 0
                                    task.wait(0.1)
                                    fireproximityprompt(e)
                                    fireproximityprompt(e)
                                    fireproximityprompt(e)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end
auto:Toggle("自动拾取材料", "", false, function(v)
    autocl = v
    if collectClLoop then 
        task.cancel(collectClLoop)
        collectClLoop = nil 
    end
    if autocl then
        collectClLoop = task.spawn(collectMaterial)
    end
end)

-- 传送到圣诞礼物+秒摧毁（保留原生逻辑）
local autoTpToGift = false
local giftTpLoop = nil
local giftTpOffset = Vector3.new(0,1,0)
local function tpPlayerToGiftAndDestroy()
    while autoTpToGift do
        task.wait(0.03)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        if not hrp or not humanoid or humanoid.Health <=0 then continue end
        local mobFolder = workspace:FindFirstChild("Christmas") and workspace.Christmas:FindFirstChild("Mobs")
        if not mobFolder then continue end
        for _, mob in ipairs(mobFolder:GetChildren()) do
            if mob:GetAttribute("mobName") and (mob:GetAttribute("mobName") == "Present" or mob:GetAttribute("mobName") == "BigPresent") then
                pcall(function()
                    local mobRoot = mob.PrimaryPart or mob:FindFirstChildWhichIsA("BasePart")
                    if not mobRoot then return end
                    hrp:PivotTo(mobRoot.CFrame + giftTpOffset)
                    mob:SetAttribute("health", 0)
                    local prompt = mob:FindFirstChildOfClass("ProximityPrompt") or mob:FindFirstChildWhichIsA("ProximityPrompt", true)
                    if prompt then triggerCollectCustom(prompt) end
                    task.wait(0.01)
                end)
            end
        end
    end
end
auto:Toggle("传送到圣诞礼物+秒摧毁", "", false, function(v)
    autoTpToGift = v
    if giftTpLoop then 
        task.cancel(giftTpLoop)
        giftTpLoop = nil 
    end
    if autoTpToGift then
        giftTpLoop = task.spawn(tpPlayerToGiftAndDestroy)
    end
end)

-- 自动拾取CashBundle金钱堆（保留原生逻辑）
local autoCollectCash = false
local cashCollectLoop = nil
local CashConfig = {
    RootPath = workspace:WaitForChild("Game",3) and workspace.Game:WaitForChild("Entities",3) and workspace.Game.Entities:WaitForChild("CashBundle",3) or nil,
    ClickDelay = 0,
    Offset = Vector3.new(0,0.5,0)
}
local function getCashTarget()
    if not CashConfig.RootPath then return nil end
    local targets = {}
    for _,child in ipairs(CashConfig.RootPath:GetChildren()) do
        if child:IsA("BasePart") and child.Parent then
            table.insert(targets, child)
        end
    end
    return #targets>0 and targets[1] or nil
end
local function autoCollectCashBundle()
    while autoCollectCash do
        task.wait(CashConfig.ClickDelay)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end
        local target = getCashTarget()
        if not target then continue end
        hrp.CFrame = CFrame.new(target.Position + CashConfig.Offset)
        local remote = target:FindFirstChildOfClass("RemoteEvent") or target:FindFirstChildOfClass("RemoteFunction") or game.ReplicatedStorage:FindFirstChild("CashPickup", true) or ReplicatedStorage.devv.remoteStorage:FindFirstChild("CashPickup", true)
        if remote then
            pcall(function()
                if remote:IsA("RemoteEvent") then 
                    remote:FireServer(target)
                elseif remote:IsA("RemoteFunction") then 
                    remote:InvokeServer(target)
                end
            end)
        end
    end
end
auto:Toggle("自动拾取CashBundle金钱堆", "", false, function(v)
    autoCollectCash = v
    if cashCollectLoop then 
        task.cancel(cashCollectLoop)
        cashCollectLoop = nil 
    end
    if autoCollectCash then
        cashCollectLoop = task.spawn(autoCollectCashBundle)
    end
end)

-- 子追开关+忽略好友
auto:Toggle("子追开关", "killopp", false, function(state)
    killoppEnabled = state 
end)
auto:Toggle("忽略好友", "ignorefriends", false, function(state)
    ignoreFriendsEnabled = state 
end)

-- ATMs专属传送摧毁（仅摧毁未处理的ATM+冷却保留）
local autoTpDestroyATM = false
local atmTpDestroyLoop = nil
local atmOffset = Vector3.new(0, 1, 0)
local function tpDestroyATM()
    while autoTpDestroyATM do
        task.wait(0.8)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        if not hrp or not humanoid or humanoid.Health <= 0 then continue end

        local atmFolder = workspace:FindFirstChild("ATMs")
        if atmFolder then
            for _, atm in ipairs(atmFolder:GetChildren()) do
                if not processedATM[atm] then
                    pcall(function()
                        local currentTime = tick()
                        if currentTime - lastTpTime >= TP_COOLDOWN then
                            local atmPart = atm.PrimaryPart or atm:FindFirstChildWhichIsA("BasePart") or atm
                            hrp.CFrame = atmPart.CFrame + atmOffset
                            lastTpTime = currentTime
                            if atm:GetAttribute("health") then 
                                atm:SetAttribute("health", 0) 
                            end
                            if atm:FindFirstChildOfClass("ProximityPrompt") then
                                local atmPrompt = atm:FindFirstChildOfClass("ProximityPrompt")
                                atmPrompt.HoldDuration = 0
                                triggerCollectCustom(atmPrompt)
                            end
                            processedATM[atm] = true
                            atm.AncestryChanged:Connect(function(_, parent)
                                if not parent then processedATM[atm] = nil end
                            end)
                        end
                    end)
                end
            end
        end
    end
end
auto:Toggle("ATMs专属-仅摧毁未处理ATM（保留物体）", "", false, function(v)
    autoTpDestroyATM = v
    if atmTpDestroyLoop then 
        task.cancel(atmTpDestroyLoop) 
        atmTpDestroyLoop = nil 
    end
    if autoTpDestroyATM then
        atmTpDestroyLoop = task.spawn(tpDestroyATM)
    end
end)

-- 收集标签页（保留原生查找印钞机逻辑）
local main = window:Tab("收集")
local zzjwp = main:section("收集", true)
zzjwp:Toggle("查找放下来印钞机","", false, function(v)
    czycj = v
    if czycj then
        task.spawn(function()
            while czycj and task.wait() do
                local localPlayer = Players.LocalPlayer 
                local droppables = workspace.Game.Local.droppables 
                if droppables and droppables:FindFirstChild("Money Printer") then 
                    local unusualMoneyPrinter = droppables:FindFirstChild("Money Printer")
                    for _,child in pairs(unusualMoneyPrinter:GetChildren()) do 
                        if child:IsA("MeshPart") then 
                            local humanoidRootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
                            if humanoidRootPart then
                                humanoidRootPart.CFrame = CFrame.new(child.Position)
                                local prompt = unusualMoneyPrinter:FindFirstChildOfClass("ProximityPrompt") or unusualMoneyPrinter:FindFirstChildWhichIsA("ProximityPrompt", true)
                                if prompt then triggerCollectCustom(prompt) end
                            end
                        end 
                    end 
                end
            end
        end)
    end
end)

-- 空投ESP核心功能
local airdropESPEnabled = true
local airdropESPList = {}
local function createAirdropESP(airdropObj)
    if airdropESPList[airdropObj] or not airdropObj:IsA("Model") then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "AirdropESP_Highlight"
    highlight.Adornee = airdropObj
    highlight.FillColor = Color3.new(1, 0, 0)
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = Color3.new(1, 1, 0)
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = airdropObj
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "AirdropESP_Billboard"
    billboard.Adornee = airdropObj:FindFirstChildWhichIsA("BasePart") or airdropObj
    billboard.Size = UDim2.new(0, 300, 0, 100)
    billboard.StudsOffset = Vector3.new(0, 5, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = airdropObj
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = Color3.new(1, 1, 1)
    text.TextStrokeColor3 = Color3.new(0,0,0)
    text.TextStrokeTransparency = 0.2
    text.Font = Enum.Font.GothamBold
    text.TextSize = 16
    text.Text = string.format("[空投] %s", airdropObj.Name)
    text.Parent = billboard
    airdropESPList[airdropObj] = {highlight, billboard}
    airdropObj.AncestryChanged:Connect(function(_, parent)
        if not parent and airdropESPList[airdropObj] then
            for _, obj in ipairs(airdropESPList[airdropObj]) do 
                obj:Destroy() 
            end
            airdropESPList[airdropObj] = nil
        end
    end)
end
local function initAirdropESP()
    local airdropFolder = workspace.Game:FindFirstChild("Airdrops") or workspace.Game:WaitForChild("Airdrops",5)
    if not airdropFolder then return end
    for _, airdrop in ipairs(airdropFolder:GetChildren()) do
        if airdrop.Name == "Airdrop" or airdrop.Name == "Santadrop" then
            task.spawn(createAirdropESP, airdrop)
        end
    end
    airdropFolder.ChildAdded:Connect(function(child)
        if (child.Name == "Airdrop" or child.Name == "Santadrop") and airdropESPEnabled then
            task.wait(0.2)
            createAirdropESP(child)
        end
    end)
end
initAirdropESP()
auto:Toggle("空投ESP（红色高亮+穿透显示）", "", true, function(v)
    airdropESPEnabled = v
    for airdrop, espObjs in pairs(airdropESPList) do
        for _, obj in ipairs(espObjs) do 
            obj.Enabled = v 
        end
    end
end)

-- 子追逻辑（完整保留）
local game = game 
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera 
local UserInputService = game:GetService("UserInputService")
local old 
local TEXT_POSITION = Vector2.new(Camera.ViewportSize.X - 200,50)
local TEXT_COLOR = Color3.new(1,1,1)
local HEALTH_COLOR = Color3.new(0,1,0)
local targetDisplay = Drawing.new("Text")
targetDisplay.Visible = false 
targetDisplay.Size = 20 
targetDisplay.Center = false 
targetDisplay.Outline = true 
targetDisplay.OutlineColor = Color3.new(0,0,0)
targetDisplay.Color = TEXT_COLOR 
targetDisplay.Text = "目标: None" 
targetDisplay.Position = TEXT_POSITION 
targetDisplay.Font = 2 
local healthDisplay = Drawing.new("Text")
healthDisplay.Visible = false 
healthDisplay.Size = 18 
healthDisplay.Center = true 
healthDisplay.Outline = true 
healthDisplay.OutlineColor = Color3.new(0,0,0)
healthDisplay.Color = HEALTH_COLOR 
healthDisplay.Font = 2 
local usernameDisplay = Drawing.new("Text")
usernameDisplay.Visible = false 
usernameDisplay.Size = 18 
usernameDisplay.Center = true 
usernameDisplay.Outline = true 
usernameDisplay.OutlineColor = Color3.new(0,0,0)
usernameDisplay.Color = TEXT_COLOR 
usernameDisplay.Font = 2 
local function isFriend(player)
    if not ignoreFriendsEnabled then return false end 
    local success,isFriend = pcall(function()
        return LocalPlayer:IsFriendsWith(player.UserId)
    end)
    return success and isFriend 
end 
local function updateDisplay(character,player)
    local head = character and character:FindFirstChild("Head")
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    if not head or not humanoid then 
        healthDisplay.Visible = false 
        usernameDisplay.Visible = false 
        return 
    end 
    local headPos,headOnScreen = Camera:WorldToViewportPoint(head.Position)
    if not headOnScreen then 
        healthDisplay.Visible = false 
        usernameDisplay.Visible = false 
        return 
    end 
    healthDisplay.Text = math.floor(humanoid.Health).."/"..math.floor(humanoid.MaxHealth)
    healthDisplay.Position = Vector2.new(headPos.X,headPos.Y - 30)
    healthDisplay.Visible = true 
    usernameDisplay.Text = player.Name 
    usernameDisplay.Position = Vector2.new(headPos.X,headPos.Y - 50)
    usernameDisplay.Visible = true 
end 
local function getClosestHead()
    local closestHead 
    local closestPlayer 
    local closestCharacter 
    local closestDistance = math.huge 
    local cameraDirection = Camera.CFrame.LookVector 
    local cameraPos = Camera.CFrame.Position 
    for _,player in ipairs(Players:GetPlayers()) do 
        if player ~= LocalPlayer and player.Character then 
            if ignoreFriendsEnabled and isFriend(player) then continue end 
            local character = player.Character 
            local head = character:FindFirstChild("Head")
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            local forcefield = character:FindFirstChild("ForceField")
            if head and humanoid and not forcefield and humanoid.Health > 0 then 
                local distance = (head.Position - cameraPos).Magnitude 
                if distance < closestDistance then 
                    closestHead = head 
                    closestPlayer = player 
                    closestCharacter = character 
                    closestDistance = distance 
                end 
            end 
        end 
    end 
    return closestHead,closestPlayer,closestCharacter 
end 
RunService.Heartbeat:Connect(function()
    if not killoppEnabled then 
        targetDisplay.Visible = false 
        healthDisplay.Visible = false 
        usernameDisplay.Visible = false 
        return 
    end 
    local closestHead,closestPlayer,closestCharacter = getClosestHead()
    if closestHead and closestPlayer then 
        targetDisplay.Text = "目标: "..closestPlayer.Name 
        targetDisplay.Visible = true 
        updateDisplay(closestCharacter,closestPlayer)
    else 
        targetDisplay.Text = "目标: None" 
        targetDisplay.Visible = true 
        healthDisplay.Visible = false 
        usernameDisplay.Visible = false 
    end 
end)
old = hookmetamethod(game,"__namecall",function(self,...)
    if not killoppEnabled then return old(self,...) end 
    local method = getnamecallmethod()
    local args = {...}
    if (method == "Raycast" or method == "FindPartOnRay") and not checkcaller() and self == Workspace then 
        local origin,direction 
        if method == "Raycast" then 
            origin = args[1]
            direction = args[2]
        else 
            local ray = args[1]
            if typeof(ray) == "Ray" then 
                origin = ray.Origin 
                direction = ray.Direction 
            end 
        end 
        if origin and direction then 
            local closestHead,closestPlayer = getClosestHead()
            if closestHead and closestPlayer then 
                if not (ignoreFriendsEnabled and isFriend(closestPlayer)) then 
                    return {
                        Instance = closestHead,
                        Position = closestHead.Position,
                        Normal = (closestHead.Position - origin).Unit,
                        Material = Enum.Material.Plastic
                    }
                end 
            end 
        end 
    end 
    return old(self,...)
end)
local function cleanup()
    targetDisplay:Remove()
    healthDisplay:Remove()
    usernameDisplay:Remove()
end 
game:GetService("UserInputService").WindowFocusReleased:Connect(cleanup)

print("✅ 脚本加载完成｜储物柜功能已整合到魔法标签｜仅背包打开时运行（已修复Visible/Enabled错误）")

